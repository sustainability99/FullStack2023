## Юнит-тестирование

**Модульное тестирование**, или **юнит-тестирование** (*англ.* **unit testing**) — процесс в
программировании, позволяющий проверить на корректность отдельные модули (методы) исходного кода
программы.

### Зачем и когда пишуться тесты
Тесты пишутся программистами в идеале для каждого метода класса, который сложнее, чем sout или вызов
стандартных имеющихся в Java методов. Обычно, тесты пишет сам программист или другой
прграммист-коллега (junior) **параллельно** по ходу разработки или в ходе рефакторинга
(это обычный/регулярный процесс).

Модульное тестирование позволяет достаточно быстро проверить, не привело ли очередное изменение кода
(рефакторинг) к его регрессии, то есть к появлению ошибок в уже оттестированных местах программы.
Тестирование облегчает обнаружение и устранение таких ошибок, НО не обеспечивает полной гарантии.

**ВНИМАНИЕ!!!**
Можно добится 100% покрытия кода тестами, но не 100% уверенности, что тесты проверяют ВСЕ СЛУЧАИ и
ВСЕ НАБОРЫ НАННЫХ - это все остается на совести самих программистов.

#### Не нужно писать тесты, если
вы обладаете идеальной памятью и даром предвидения, ваш код способен изменять себя сам,
вслед за требованиями клиента, а иногда он объясняет клиенту, что его требования не нужно реализовывать.

**Любой долгосрочный проект без надлежащего покрытия тестами обречен рано или поздно
быть переписанным с нуля.**

**Тесты должны:**
- Быть достоверными, то есть проверять верные случаи и утверждения;
- Не зависеть от окружения, на котором они выполняются;
- Легко поддерживаться, то есть легко читаться и быть простыми для понимания,
  даже новый разработчик должен понять, **что именно** тестируется;
- Соблюдать единую конвенцию именования;
- Запускаться регулярно в автоматическом режиме.

**Алгоритм проведения Unit тестов**
1. Выбрать/создать директорию для проведения Unit-тестирования (обычно - в директории где
   находится тестируемый класс и его методы)
2. Создать в этой директории новый класс (java-файл) с наименованием ИмяКлассаTest
3. Выполнить в этот Класс (файл) импорт библиотек:
   import org.junit.jupiter.api.Assertions;
   import org.junit.jupiter.api.BeforeEach;
   import org.junit.jupiter.api.Test;
4. Подключаем тестируемый класс и его методы строкой вида:
   ИмяКласса имяКласса;
5. Директива @BeforeEach
   void setUp(){
   Имя класса = new ИмяKласса(); // создаем экземпляр тестируемого класса перед каждым тестом
   }
6. Директивы
   @Test
   @DisplayName("Описать что мы тестируем")
   создаь метод, вызывающий assertEquals (нужное значение, вызов тестируемого метода , "Сообщение(пояснение) о ...")
   Пример:   
   void testMultiPly(){
   assertEquals(20,calculator.multiply(4,5),"4*5 should be 20");
   }
7. Запустить тест

Один из возможных способов именования методов класса для проведения тестирования такой:
`[Тестируемый метод]_[Сценарий]_[Ожидаемое поведение]`.

Предположим, что у нас есть класс `Calculator`, а у него есть метод `sum`, который должен складывать два числа.
В этом случае наш тестирующий класс будет выглядеть так:
```java
import static org.junit.jupiter.api.Assertions.assertEquals;

import org.junit.jupiter.api.Test;

public сlass CalculatorTests {

	@Test
  public void sum_2Plus5_7Returned() {
    // …
  }
}
```
Такая запись понятна без объяснений. Это спецификация к коду и его тесту.

## Придерживайтесь единого стиля написания тела теста
Отлично зарекомендовал себя подход **AAA**
(arrange, act, assert - упорядочить, выполнить действие, сравнить результат).

Пример того, как это выглядит на примере с калькулятором:
```java
import static org.junit.jupiter.api.Assertions.assertEquals;

import org.junit.jupiter.api.Test;

public class CalculatorTests {

  @Test
	public void sum_2Plus5_7Returned() {
		// arrange
		Calculator calc = new Calculator(); // создали свой экземпляр калькулятора
	
		// act
		int res = calc.sum(2, 5); // вызвали метод из тестируемого класса

		// assert
		assertEquals(7, res); // выполнили сравнение желаемого с полученным
	}
}
```
Такая форма записи гораздо легче читается, чем
```java
import static org.junit.jupiter.api.Assertions.assertEquals;

import org.junit.jupiter.api.Test;

public class CalculatorTests {

  @Test
	public void sum_2Plus5_7Returned() {
		assertEquals(7, new Calculator().sum(2, 5));
	}
}
```

## Тестируйте один метод за один раз
Каждый тест должен охватывать одну понятную область и/или возможность.
Если процесс слишком сложен (например, покупка в интернет магазине),
разделите его на несколько частей и протестируйте их отдельно.
Если вы не будете придерживаться этого правила, ваши тесты станут нечитаемыми
и вскоре вам окажется очень сложно их поддерживать.

# Фреймворк JUnit

**JUnit** - один из самых популярных фреймворков, используемых для тестирования кода в **Java**.

[Официальный сайт](https://junit.org/junit5/)

[Руководство пользователя](https://junit.org/junit5/docs/current/user-guide/)

[Репозиторий](https://github.com/junit-team/junit5/) на **GitHub**

[Текстовая инструкция по настройке IntelliJ Idea (на английском)](https://www.jetbrains.com/help/idea/junit.html)

[Видеоинструкция по настройке IntelliJ Idea (на английском)](https://www.youtube.com/watch?v=we3zJE3hlWE)


## Нужные импорты

Эти два импорта заставят IntelliJ Idea предложить вам установить JUnit:
```java
import static org.junit.jupiter.api.Assertions.assertEquals;

import org.junit.jupiter.api.Test;
```